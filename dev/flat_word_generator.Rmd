---
title: "Generate word"
output: html_document
editor_options:
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

## Generate a word from a brick

```{r function-generate_from_brick}
#' Generate a word from a regex brick
#'
#' @param brick list. A list of the regex specifics
#' @param use_scrabble logical. Should the regex try to match a real word
#' @param maxword integer. Maximum number of random word to return
#' @param maxfreq integer. Boundary when no maximum occurrence is specified
#'
#' @importFrom purrr map_chr
#'
#' @return wordlist. A character string matching the regex.
#' @export
#'
#' @examples
generate_from_brick <- function(
    brick,
    use_scrabble = TRUE,
    maxword = 10,
    maxfreq = 10) {
  # verify brick list
  brick_items <- c(
    "brick",
    "type",
    "content",
    "occurrence",
    "custom_motif",
    "custom_occurrence"
  )

  if (!all(brick_items %in% names(brick))) {
    stop("brick input list does not have all required items")
  }

  if (brick$type == "ordered") {
    # repeat motif accoring to occurrence
    occurrence_equivalence <- list(
      "once" = 1,
      "at least once" = 1:maxfreq,
      "anytime" = 0:maxfreq,
      "custom" = brick$custom_occurrence[1]:brick$custom_occurrence[2]
    )
    motif_reps <- occurrence_equivalence[[brick$occurrence]]

    invented_match <- map_chr(motif_reps, \(x){
      paste(rep(brick$custom_motif, x), collapse = "")
    })

    if (length(invented_match) > maxword) {
      invented_match <- sample(invented_match, size = maxword, replace = FALSE)
    }

    return(invented_match)
  } else if (brick$type == "unordered") {
    if (use_scrabble) {
      scrabble_match <- search_in_scrabble(brick$brick)
    }

    # generate from sampling
    extra_word_to_generate <- max(0, maxword - length(scrabble_match))
    if (extra_word_to_generate == 0) {
      return(sample(scrabble_match, maxword))
    } else {
      all_characters <- unlist(strsplit(rawToChar(as.raw(1:127)), ""))
      char_bucket <- list(
        "lowercase letters" = LETTERS,
        "uppercase letters" = letters,
        "digits" = 0:9,
        "punctuation" = grep("[[:punct:]]", all_characters, value = TRUE),
        "space and tab" = grep("[[:blank:]]", all_characters, value = TRUE),
        "wildcard" = grep(".", all_characters, value = TRUE),
        "custom" = strsplit(brick$custom_motif, "")
      )
      char_bucket <- unique(unlist(char_bucket[brick$content]))

      # complete scrabble list up to max_word
      if (brick$occurrence == "once") {
        repeats <- 1
      } else if (brick$occurrence != "custom") {
        repeats <- sample.int(
          maxfreq,
          size = extra_word_to_generate,
          replace = TRUE
        )
      } else if (brick$occurrence == "custom") {
        custom_occurrence[2] <- sub(
          "no max",
          maxfreq,
          brick$custom_occurrence[2]
        )
        sample_range <- seq.int(
          from = as.numeric(brick$custom_occurrence[1]),
          to = max(c(maxfreq, as.numeric(brick$custom_occurrence[2])))
        )
        repeats <- sample.int(
          sample_range,
          size = extra_word_to_generate,
          replace = TRUE
        )
      }
      invented_match <- map_chr(
        .x = repeats,
        .f = \(x) {
          paste0(
            sample(
              x = char_bucket,
              size = x,
              replace = TRUE
            ),
            collapse = ""
          )
        }
      )
      return(c(scrabble_match, invented_match))
    }
  }
}
```

```{r examples-generate_from_brick}
# generate_from_brick(brick)
```

```{r tests-generate_from_brick}
test_that("function returns error for unexpected input", {

})
```

## Search a word in Scarbble

```{r function-search_in_scrabble}
#' Search a word from Scrabble with regex
#'
#' @param brick list. A list of the regex specifics
#'
#' @importFrom purrr map2
#'
#' @return wordlist. A character string matching the regex.
#' @export
#'
#' @noRd
search_in_scrabble <- function(
    brick) {
  # search work for unorderd (lower or upper case)
  match_all <- grep(
    pattern = paste0("^(", brick, ")$"),
    x = c(wordlist, toupper(wordlist))
  )

  # TODO : case-sensitive generation
  return(unique(wordlist[match_all]))
}
```

```{r examples-generate_from_brick}
search_in_scrabble(brick = "morning")
```

```{r tests-generate_from_brick}
test_that("function returns error for unexpected input", {

})
```

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_word_generator.Rmd",
  vignette_name = NA,
  check = FALSE,
  open_vignette = FALSE
)
```

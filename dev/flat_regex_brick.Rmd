---
title: "Build bricks"
output: html_document
editor_options:
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

## Build a regex brick

```{r function-build_a_regex_brick}
#' Build a regex brick
#'
#' @param type character. The type of regex group.
#' Can be "ordered" or "unordered".
#' @param content character. The content of the regex group.
#' Can be "wildcard", "lowercase letters", "uppercase letters", "digits",
#' "punctuation", "space and tab", or "custom".
#' @param occurrence character. The occurrence of the regex group.
#' Can be "once", "at least once", "anytime", or "custom".
#' @param custom_motif character. The custom motif to be used in a regex group.
#' Only applicable if "custom" is selected for the content parameter.
#' @param custom_occurrence integer. The occurrence to be used in a regex group.
#' Only applicable if "custom" is selected for the occurrence parameter.
#' @param escape logical. Should special characters in custom motif be escaped.
#'
#' @importFrom stringr str_escape
#'
#' @return A character string representing the built regex.
#' @export
#'
#' @examples
build_a_regex_brick <- function(
    type = c("ordered", "unordered"),
    content = c("wildcard", "lowercase letters", "uppercase letters", "digits", "punctuation", "space and tab", "custom"),
    occurrence = c("once", "at least once", "anytime", "custom"),
    custom_motif = NULL,
    custom_occurrence = NULL,
    escape = TRUE) {
  # check input
  type <- match.arg(type)
  content <- match.arg(content, several.ok = TRUE)
  occurrence <- match.arg(occurrence)

  # check cusom
  if ("custom" %in% occurrence && is.null(custom_occurrence)) {
    stop("custom occurrence selected but no value given")
  }
  if ("custom" %in% content && is.null(custom_motif)) {
    stop("custom motif selected but no value given")
  }

  # escape special character
  if (isTRUE(escape)) {
    # escape special
    custom_motif <- str_escape(custom_motif)
    # avoid creating range in unordered input with `-`
    if (type == "unordered" && grepl("-", custom_motif)) {
      custom_motif <- paste0("-", gsub("-", "", custom_motif))
    }
  }

  # set occurrence
  if (occurrence != "custom") {
    occurrence_equivalence <- list(
      "once" = "",
      "at least once" = "+",
      "anytime" = "*"
    )
    custom_occurrence <- NULL
    freq <- occurrence_equivalence[occurrence]
  } else {
    custom_occurrence[2] <- sub("no max", "", custom_occurrence[2])
    freq <- sprintf("{%s,%s}", custom_occurrence[1], custom_occurrence[2])
  }

  # set group
  if (type == "ordered") {
    group_bracket <- c("(", ")")

    # we only allow custom motif for ordered group for now
    text <- sprintf(
      "%s%s%s%s",
      group_bracket[1],
      custom_motif,
      group_bracket[2],
      freq
    )
    # remove unused parameters
    content <- NULL
  } else if (type == "unordered") {
    group_bracket <- c("[", "]")

    # set content
    regex_equivalance <- c(
      "wildcard" = ".",
      "lowercase letters" = "[:lower:]",
      "uppercase letters" = "[:upper:]",
      "digits" = "[:digit:]",
      "punctuation" = "[:punct:]",
      "space and tab" = "[:blank:]",
      "custom" = custom_motif
    )

    text <- sprintf(
      "%s%s%s%s",
      group_bracket[1],
      paste(regex_equivalance[content], collapse = ""),
      group_bracket[2],
      freq
    )
  }

  new_brick <- list(
    brick = text,
    type = type,
    content = content,
    occurrence = occurrence,
    custom_motif = custom_motif,
    custom_occurrence = custom_occurrence
  )

  return(new_brick)
}
```

```{r examples-build_a_regex_brick}
build_a_regex_brick(
  type = "ordered",
  occurrence = "custom",
  custom_motif = "hello$",
  custom_occurrence = c(1, 5)
)

build_a_regex_brick(
  type = "unordered",
  occurrence = "anytime",
  custom_motif = "hello!",
  content = c("lowercase letters", "uppercase letters", "custom")
)
```

```{r tests-build_a_regex_brick}
test_that("function returns error for unexpected input", {
  expect_error({
    build_a_regex_brick(type = "unknown")
  })
  expect_error({
    build_a_regex_brick(content = "unknown")
  })
  expect_error({
    build_a_regex_brick(occurrence = "unknown")
  })
  expect_error(
    {
      build_a_regex_brick(occurrence = "custom")
    },
    regexp = "custom occurrence selected but no value given"
  )
  expect_error(
    {
      build_a_regex_brick(content = "custom")
    },
    regexp = "custom motif selected but no value given"
  )
})

test_that("function gives expected regex for ordered type", {
  regex_output <- build_a_regex_brick(
    type = "ordered",
    occurrence = "custom",
    custom_motif = "hello",
    custom_occurrence = c(1, 5)
  )
  expect_equal(object = regex_output$brick, expected = "(hello){1,5}")
})

test_that("function gives expected regex for unordered type", {
  regex_output <- build_a_regex_brick(
    type = "unordered",
    occurrence = "anytime",
    custom_motif = "hello",
    content = c("lowercase letters", "uppercase letters", "custom")
  )
  expect_equal(object = regex_output$brick, expected = "[[:lower:][:upper:]hello]*")
})
```

## Validate a regex brick

```{r function-validate_regex}
#' Validate a regex combination
#'
#' @param bricks character. The ordered list of regex bricks
#'
#' @importFrom shinyWidgets show_toast
#'
#' @return logical. Side effect : trigger a toast widget
#' @export
#'
#' @examples
validate_regex <- function(bricks) {
  if ("start" %in% bricks && bricks[1] != "start") {
    show_toast(
      title = "woups",
      text = "start `^` should be the first element",
      type = "warning",
      timer = 3000,
      width = "400px"
    )
    return(FALSE)
  }
  if ("end" %in% bricks && bricks[length(bricks)] != "end") {
    show_toast(
      title = "woups",
      text = "end `$` should be the last element",
      type = "warning",
      timer = 3000,
      width = "400px"
    )
    return(FALSE)
  }
  if ("or" %in% bricks) {
    or_idx <- which(bricks == "or")
    is_first_or_last <- any(c(1, length(bricks)) %in% or_idx)

    if (is_first_or_last) {
      # cannot be first or last
      show_toast(
        title = "woups",
        text = "or `|` should not be 1st or last element",
        type = "warning",
        timer = 3000,
        width = "400px"
      )
      return(FALSE)
    }

    right_idx <- or_idx + 1[or_idx != length(bricks)]
    left_idx <- or_idx - 1[or_idx != 1]

    is_next_to_helper <- any(
      c("start", "end", "or") %in% bricks[c(left_idx, right_idx)]
    )

    if (is_next_to_helper) {
      show_toast(
        title = "woups",
        text = "or `|` should not be next to another helper",
        type = "warning",
        timer = 3000,
        width = "400px"
      )
      return(FALSE)
    }
  }
  return(TRUE)
}
```

```{r examples-validate_regex}
validate_regex(bricks = list("yes", "or", "no"))
```

```{r tests-validate_regex}
test_that("function returns no warning for correct regex", {
  expect_true({
    validate_regex(bricks = list("yes", "or", "no"))
  })
})
```


```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_regex_brick.Rmd",
  vignette_name = NA,
  check = FALSE,
  open_vignette = FALSE
)
```
